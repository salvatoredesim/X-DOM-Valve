

/**
  ******************************************************************************
  * @file    bluenrg1.c
  * @author  AMS - VMA RF Application team
  * @version V1.0.0
  * @date    21-Sept-2015
  * @brief   Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
  ******************************************************************************
  */
#include "bluenrg1_gap_aci.h"
#include "bluenrg1_events.h"
#include "osal.h"
#include <stdint.h>
tBleStatus hci_disconnection_complete_event_process(uint8_t *buffer_in);
tBleStatus hci_encryption_change_event_process(uint8_t *buffer_in);
tBleStatus hci_read_remote_version_information_complete_event_process(uint8_t *buffer_in);
tBleStatus hci_hardware_error_event_process(uint8_t *buffer_in);
tBleStatus hci_number_of_completed_packets_event_process(uint8_t *buffer_in);
tBleStatus hci_data_buffer_overflow_event_process(uint8_t *buffer_in);
tBleStatus hci_encryption_key_refresh_complete_event_process(uint8_t *buffer_in);
tBleStatus aci_blue_initialized_event_process(uint8_t *buffer_in);
tBleStatus aci_gap_limited_discoverable_event_process(uint8_t *buffer_in);
tBleStatus aci_gap_pairing_complete_event_process(uint8_t *buffer_in);
tBleStatus aci_gap_pass_key_req_event_process(uint8_t *buffer_in);
tBleStatus aci_gap_authorization_req_event_process(uint8_t *buffer_in);
tBleStatus aci_gap_slave_security_initiated_event_process(uint8_t *buffer_in);
tBleStatus aci_gap_bond_lost_event_process(uint8_t *buffer_in);
tBleStatus aci_gap_proc_complete_event_process(uint8_t *buffer_in);
tBleStatus aci_gap_addr_not_resolved_event_process(uint8_t *buffer_in);
tBleStatus aci_l2cap_connection_update_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_l2cap_proc_timeout_event_process(uint8_t *buffer_in);
tBleStatus aci_l2cap_connection_update_req_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_attribute_modified_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_proc_timeout_event_process(uint8_t *buffer_in);
tBleStatus aci_att_exchange_mtu_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_find_info_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_find_by_type_value_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_read_by_type_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_read_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_read_blob_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_read_multiple_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_read_by_group_type_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_prepare_write_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_att_exec_write_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_indication_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_notification_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_proc_complete_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_error_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_disc_read_char_by_uuid_resp_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_write_permit_req_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_read_permit_req_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_read_multi_permit_req_event_process(uint8_t *buffer_in);
tBleStatus hci_le_connection_complete_event_process(uint8_t *buffer_in);
tBleStatus hci_le_advertising_report_event_process(uint8_t *buffer_in);
tBleStatus hci_le_connection_update_complete_event_process(uint8_t *buffer_in);
tBleStatus hci_le_read_remote_used_features_complete_event_process(uint8_t *buffer_in);
tBleStatus hci_le_long_term_key_request_event_process(uint8_t *buffer_in);
tBleStatus aci_l2cap_command_reject_event_process(uint8_t *buffer_in);
tBleStatus aci_hal_end_of_radio_activity_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_tx_pool_available_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_server_confirmation_event_process(uint8_t *buffer_in);
tBleStatus aci_blue_events_lost_event_process(uint8_t *buffer_in);
tBleStatus aci_blue_crash_info_event_process(uint8_t *buffer_in);
tBleStatus aci_gatt_prepare_write_permit_req_event_process(uint8_t *buffer_in);
const hci_events_table_type hci_events_table[7] = {
  /* hci_disconnection_complete_event */
  0x0005, hci_disconnection_complete_event_process,
  /* hci_encryption_change_event */
  0x0008, hci_encryption_change_event_process,
  /* hci_read_remote_version_information_complete_event */
  0x000c, hci_read_remote_version_information_complete_event_process,
  /* hci_hardware_error_event */
  0x0010, hci_hardware_error_event_process,
  /* hci_number_of_completed_packets_event */
  0x0013, hci_number_of_completed_packets_event_process,
  /* hci_data_buffer_overflow_event */
  0x001a, hci_data_buffer_overflow_event_process,
  /* hci_encryption_key_refresh_complete_event */
  0x0030, hci_encryption_key_refresh_complete_event_process,
};
const hci_le_meta_events_table_type hci_le_meta_events_table[5] = {
  /* hci_le_connection_complete_event */
  0x0001, hci_le_connection_complete_event_process,
  /* hci_le_advertising_report_event */
  0x0002, hci_le_advertising_report_event_process,
  /* hci_le_connection_update_complete_event */
  0x0003, hci_le_connection_update_complete_event_process,
  /* hci_le_read_remote_used_features_complete_event */
  0x0004, hci_le_read_remote_used_features_complete_event_process,
  /* hci_le_long_term_key_request_event */
  0x0005, hci_le_long_term_key_request_event_process,
};
const hci_vendor_specific_events_table_type hci_vendor_specific_events_table[39] = {
  /* aci_blue_initialized_event */
  0x0001, aci_blue_initialized_event_process,
  /* aci_gap_limited_discoverable_event */
  0x0400, aci_gap_limited_discoverable_event_process,
  /* aci_gap_pairing_complete_event */
  0x0401, aci_gap_pairing_complete_event_process,
  /* aci_gap_pass_key_req_event */
  0x0402, aci_gap_pass_key_req_event_process,
  /* aci_gap_authorization_req_event */
  0x0403, aci_gap_authorization_req_event_process,
  /* aci_gap_slave_security_initiated_event */
  0x0404, aci_gap_slave_security_initiated_event_process,
  /* aci_gap_bond_lost_event */
  0x0405, aci_gap_bond_lost_event_process,
  /* aci_gap_proc_complete_event */
  0x0407, aci_gap_proc_complete_event_process,
  /* aci_gap_addr_not_resolved_event */
  0x0408, aci_gap_addr_not_resolved_event_process,
  /* aci_l2cap_connection_update_resp_event */
  0x0800, aci_l2cap_connection_update_resp_event_process,
  /* aci_l2cap_proc_timeout_event */
  0x0801, aci_l2cap_proc_timeout_event_process,
  /* aci_l2cap_connection_update_req_event */
  0x0802, aci_l2cap_connection_update_req_event_process,
  /* aci_gatt_attribute_modified_event */
  0x0c01, aci_gatt_attribute_modified_event_process,
  /* aci_gatt_proc_timeout_event */
  0x0c02, aci_gatt_proc_timeout_event_process,
  /* aci_att_exchange_mtu_resp_event */
  0x0c03, aci_att_exchange_mtu_resp_event_process,
  /* aci_att_find_info_resp_event */
  0x0c04, aci_att_find_info_resp_event_process,
  /* aci_att_find_by_type_value_resp_event */
  0x0c05, aci_att_find_by_type_value_resp_event_process,
  /* aci_att_read_by_type_resp_event */
  0x0c06, aci_att_read_by_type_resp_event_process,
  /* aci_att_read_resp_event */
  0x0c07, aci_att_read_resp_event_process,
  /* aci_att_read_blob_resp_event */
  0x0c08, aci_att_read_blob_resp_event_process,
  /* aci_att_read_multiple_resp_event */
  0x0c09, aci_att_read_multiple_resp_event_process,
  /* aci_att_read_by_group_type_resp_event */
  0x0c0a, aci_att_read_by_group_type_resp_event_process,
  /* aci_att_prepare_write_resp_event */
  0x0c0c, aci_att_prepare_write_resp_event_process,
  /* aci_att_exec_write_resp_event */
  0x0c0d, aci_att_exec_write_resp_event_process,
  /* aci_gatt_indication_event */
  0x0c0e, aci_gatt_indication_event_process,
  /* aci_gatt_notification_event */
  0x0c0f, aci_gatt_notification_event_process,
  /* aci_gatt_proc_complete_event */
  0x0c10, aci_gatt_proc_complete_event_process,
  /* aci_gatt_error_resp_event */
  0x0c11, aci_gatt_error_resp_event_process,
  /* aci_gatt_disc_read_char_by_uuid_resp_event */
  0x0c12, aci_gatt_disc_read_char_by_uuid_resp_event_process,
  /* aci_gatt_write_permit_req_event */
  0x0c13, aci_gatt_write_permit_req_event_process,
  /* aci_gatt_read_permit_req_event */
  0x0c14, aci_gatt_read_permit_req_event_process,
  /* aci_gatt_read_multi_permit_req_event */
  0x0c15, aci_gatt_read_multi_permit_req_event_process,
  /* aci_l2cap_command_reject_event */
  0x080a, aci_l2cap_command_reject_event_process,
  /* aci_hal_end_of_radio_activity_event */
  0x0004, aci_hal_end_of_radio_activity_event_process,
  /* aci_gatt_tx_pool_available_event */
  0x0c16, aci_gatt_tx_pool_available_event_process,
  /* aci_gatt_server_confirmation_event */
  0x0c17, aci_gatt_server_confirmation_event_process,
  /* aci_blue_events_lost_event */
  0x0002, aci_blue_events_lost_event_process,
  /* aci_blue_crash_info_event */
  0x0003, aci_blue_crash_info_event_process,
  /* aci_gatt_prepare_write_permit_req_event */
  0x0c18, aci_gatt_prepare_write_permit_req_event_process,
};
/* hci_disconnection_complete_event */
/* Event len: 1 + 2 + 1 */
/**
  * @brief The Disconnection Complete event occurs when a connection is terminated.
The status parameter indicates if the disconnection was successful or not. The
reason parameter indicates the reason for the disconnection if the disconnection
was successful. If the disconnection was not successful, the value of the
reason parameter can be ignored by the Host. For example, this can be the
case if the Host has issued the Disconnect command and there was a parameter
error, or the command was not presently allowed, or a Connection_Handle
that didn't correspond to a connection was given.
  * @param Status Error code
  * @param Connection_Handle Connection_Handle which was disconnected.
Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
  * @param Reason Reason for disconnection.
  * @retval None
*/

tBleStatus hci_disconnection_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_disconnection_complete_event_rp0 *rp0 = (hci_disconnection_complete_event_rp0 *)buffer_in;
  hci_disconnection_complete_event(rp0->Status,
                                   rp0->Connection_Handle,
                                   rp0->Reason);

  return status;
}
/* hci_encryption_change_event */
/* Event len: 1 + 2 + 1 */
/**
  * @brief The Encryption Change event is used to indicate that the change of the encryption
mode has been completed. The Connection_Handle will be a Connection_Handle
for an ACL connection. The Encryption_Enabled event parameter
specifies the new Encryption_Enabled parameter for the Connection_Handle
specified by the Connection_Handle event parameter. This event will occur on
both devices to notify the Hosts when Encryption has changed for the specified
Connection_Handle between two devices. Note: This event shall not be generated
if encryption is paused or resumed; during a role switch, for example.
The meaning of the Encryption_Enabled parameter depends on whether the
Host has indicated support for Secure Connections in the Secure_Connections_Host_Support
parameter. When Secure_Connections_Host_Support is
'disabled' or the Connection_Handle refers to an LE link, the Controller shall
only use Encryption_Enabled values 0x00 (OFF) and 0x01 (ON).
(See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.8)
  * @param Status Error code
  * @param Connection_Handle Connection handle for which the command is given. 
Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
  * @param Encryption_Enabled - 0x00 Link Level Encryption is OFF
- 0x01 Link Level Encryption is ON with E0 for BR/EDR 
       Link Level Encryption is ON with AES-CCM for LE

- 0x02 Link Level Encryption is ON with AES-CCM for BR/EDR
- 0x03-0xFF Reserved.
  * @retval None
*/

tBleStatus hci_encryption_change_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_encryption_change_event_rp0 *rp0 = (hci_encryption_change_event_rp0 *)buffer_in;
  hci_encryption_change_event(rp0->Status,
                              rp0->Connection_Handle,
                              rp0->Encryption_Enabled);

  return status;
}
/* hci_read_remote_version_information_complete_event */
/* Event len: 1 + 2 + 1 + 2 + 2 */
/**
  * @brief The Read Remote Version Information Complete event is used to indicate the
completion of the process obtaining the version information of the remote Controller
specified by the Connection_Handle event parameter. The Connection_Handle
shall be for an ACL connection.
The Version event parameter defines the specification version of the LE Controller.
The Manufacturer_Name event parameter indicates the manufacturer
of the remote Controller. The Subversion event parameter is controlled
by the manufacturer and is implementation dependent. The Subversion
event parameter defines the various revisions that each version of the Bluetooth
hardware will go through as design processes change and errors are
fixed. This allows the software to determine what Bluetooth hardware is being
used and, if necessary, to work around various bugs in the hardware.
When the Connection_Handle is associated with an LE-U logical link, the Version
event parameter shall be Link Layer VersNr parameter, the Manufacturer_Name
event parameter shall be the CompId parameter, and the Subversion
event parameter shall be the SubVersNr parameter.
(See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.12)
  * @param Status Error code
  * @param Connection_Handle Connection handle for which the command is given. 
Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
  * @param Version Version of the Current LMP in the remote Controller
  * @param Manufacturer_Name Manufacturer Name of the remote Controller
  * @param Subversion Subversion of the LMP in the remote Controller
  * @retval None
*/

tBleStatus hci_read_remote_version_information_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_read_remote_version_information_complete_event_rp0 *rp0 = (hci_read_remote_version_information_complete_event_rp0 *)buffer_in;
  hci_read_remote_version_information_complete_event(rp0->Status,
                                                     rp0->Connection_Handle,
                                                     rp0->Version,
                                                     rp0->Manufacturer_Name,
                                                     rp0->Subversion);

  return status;
}
/* hci_hardware_error_event */
/* Event len: 1 */
/**
  * @brief The Hardware Error event is used to indicate some implementation specific type of hardware failure for the controller. This event is used to notify the Host that a hardware failure has occurred in the Controller.
  * @param Hardware_Code Hardware Error Event code.
Error code 0 means that an error on the SPI bus has been detected,
most likely caused by incorrect SPI configuration on the external micro-controller.
Error code 0x01 and 0x02 are errors caused by a slow crystal startup and they are an indication that
the HS_STARTUP_TIME in the device configuration needs to be tuned.
After this event is recommended to hardware reset the device.
  * @retval None
*/

tBleStatus hci_hardware_error_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_hardware_error_event_rp0 *rp0 = (hci_hardware_error_event_rp0 *)buffer_in;
  hci_hardware_error_event(rp0->Hardware_Code);

  return status;
}
/* hci_number_of_completed_packets_event */
/* Event len: 1 + rp0->Number_of_Handles * (sizeof(Handle_Packets_Pair_Entry_t)) */
/**
  * @brief The Number Of Completed Packets event is used by the Controller to indicate
to the Host how many HCI Data Packets have been completed (transmitted or
flushed) for each Connection_Handle since the previous Number Of Completed
Packets event was sent to the Host. This means that the corresponding
buffer space has been freed in the Controller. Based on this information, and
the HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_-
Data_Packets return parameter of the Read_Buffer_Size command, the Host
can determine for which Connection_Handles the following HCI Data Packets
should be sent to the Controller. The Number Of Completed Packets event
must not be sent before the corresponding Connection Complete event. While
the Controller has HCI data packets in its buffer, it must keep sending the Number
Of Completed Packets event to the Host at least periodically, until it finally
reports that all the pending ACL Data Packets have been transmitted or
flushed.
  * @param Number_of_Handles The number of Connection_Handles and Num_HCI_Data_Packets parameters pairs contained in this event
  * @param Handle_Packets_Pair_Entry See @ref Handle_Packets_Pair_Entry_t
  * @retval None
*/

tBleStatus hci_number_of_completed_packets_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_number_of_completed_packets_event_rp0 *rp0 = (hci_number_of_completed_packets_event_rp0 *)buffer_in;
  uint8_t size = 1;
  int i;
  Handle_Packets_Pair_Entry_t Handle_Packets_Pair_Entry[HCI_MAX_PAYLOAD_SIZE/sizeof(Handle_Packets_Pair_Entry_t)];
  for (i = 0; i < rp0->Number_of_Handles; i++) {
    Handle_Packets_Pair_Entry[i].Connection_Handle = rp0->Handle_Packets_Pair_Entry[i].Connection_Handle;
    size += 2;
    Handle_Packets_Pair_Entry[i].HC_Num_Of_Completed_Packets = rp0->Handle_Packets_Pair_Entry[i].HC_Num_Of_Completed_Packets;
    size += 2;
  }
  hci_number_of_completed_packets_event(rp0->Number_of_Handles,
                                        Handle_Packets_Pair_Entry);

  return status;
}
/* hci_data_buffer_overflow_event */
/* Event len: 1 */
/**
  * @brief This event is used to indicate that the Controller's data buffers have been overflowed.
This can occur if the Host has sent more packets than allowed. The
Link_Type parameter is used to indicate that the overflow was caused by ACL data.
  * @param Link_Type 0x00 Synchronous Buffer Overflow (Voice Channels).
0x01 ACL Buffer Overflow (Data Channels).
0x02-0xFF Reserved for future use.
  * @retval None
*/

tBleStatus hci_data_buffer_overflow_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_data_buffer_overflow_event_rp0 *rp0 = (hci_data_buffer_overflow_event_rp0 *)buffer_in;
  hci_data_buffer_overflow_event(rp0->Link_Type);

  return status;
}
/* hci_encryption_key_refresh_complete_event */
/* Event len: 1 + 2 */
/**
  * @brief The Encryption Key Refresh Complete event is used to indicate to the Host
that the encryption key was refreshed on the given Connection_Handle any
time encryption is paused and then resumed.
If the Encryption Key Refresh Complete event was generated due to an
encryption pause and resume operation embedded within a change connection
link key procedure, the Encryption Key Refresh Complete event shall be sent
prior to the Change Connection Link Key Complete event.
If the Encryption Key Refresh Complete event was generated due to an
encryption pause and resume operation embedded within a role switch procedure,
the Encryption Key Refresh Complete event shall be sent prior to the
Role Change event.
  * @param Status Error code
  * @param Connection_Handle Connection handle for which the command is given. 
Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
  * @retval None
*/

tBleStatus hci_encryption_key_refresh_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_encryption_key_refresh_complete_event_rp0 *rp0 = (hci_encryption_key_refresh_complete_event_rp0 *)buffer_in;
  hci_encryption_key_refresh_complete_event(rp0->Status,
                                            rp0->Connection_Handle);

  return status;
}
/* aci_blue_initialized_event */
/* Event len: 1 */
/**
  * @brief This event inform the application that the network coprocessor has been reset. If the reason code is a system crash,
a following event @ref aci_blue_crash_info_event will provide more information regarding the system crash details.
  * @param Reason_Code Reason code describing why device was reset and in which mode is operating (Updater or Normal mode)
  * @retval None
*/

tBleStatus aci_blue_initialized_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_blue_initialized_event_rp0 *rp0 = (aci_blue_initialized_event_rp0 *)buffer_in;
  aci_blue_initialized_event(rp0->Reason_Code);

  return status;
}
/* aci_gap_limited_discoverable_event */
/* Event len: 0 */
/**
  * @brief This event is generated by the controller when the limited discoverable mode ends due to
timeout. The timeout is 180 seconds.
  * @retval None
*/

tBleStatus aci_gap_limited_discoverable_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  aci_gap_limited_discoverable_event();

  return status;
}
/* aci_gap_pairing_complete_event */
/* Event len: 2 + 1 */
/**
  * @brief This event is generated when the pairing process has completed successfully or a pairing
procedure timeout has occurred or the pairing has failed. This is to notify the application that
we have paired with a remote device so that it can take further actions or to notify that a
timeout has occurred so that the upper layer can decide to disconnect the link.
  * @param Connection_Handle Connection handle on which the pairing procedure completed
  * @param Status Pairing status
  * @retval None
*/

tBleStatus aci_gap_pairing_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_pairing_complete_event_rp0 *rp0 = (aci_gap_pairing_complete_event_rp0 *)buffer_in;
  aci_gap_pairing_complete_event(rp0->Connection_Handle,
                                 rp0->Status);

  return status;
}
/* aci_gap_pass_key_req_event */
/* Event len: 2 */
/**
  * @brief This event is generated by the Security manager to the application when a passkey is
required for pairing. When this event is received, the application has to respond with the
@ref aci_gap_pass_key_resp command.
  * @param Connection_Handle Connection handle for which the passkey has been requested.
  * @retval None
*/

tBleStatus aci_gap_pass_key_req_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_pass_key_req_event_rp0 *rp0 = (aci_gap_pass_key_req_event_rp0 *)buffer_in;
  aci_gap_pass_key_req_event(rp0->Connection_Handle);

  return status;
}
/* aci_gap_authorization_req_event */
/* Event len: 2 */
/**
  * @brief This event is generated by the Security manager to the application when the application has
set that authorization is required for reading/writing of attributes. This event will be
generated as soon as the pairing is complete. When this event is received,
@ref aci_gap_authorization_resp command should be used to respond by the application.
  * @param Connection_Handle Connection handle for which authorization has been requested.
  * @retval None
*/

tBleStatus aci_gap_authorization_req_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_authorization_req_event_rp0 *rp0 = (aci_gap_authorization_req_event_rp0 *)buffer_in;
  aci_gap_authorization_req_event(rp0->Connection_Handle);

  return status;
}
/* aci_gap_slave_security_initiated_event */
/* Event len: 0 */
/**
  * @brief This event is generated when the slave security request is successfully sent to the master.
  * @retval None
*/

tBleStatus aci_gap_slave_security_initiated_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  aci_gap_slave_security_initiated_event();

  return status;
}
/* aci_gap_bond_lost_event */
/* Event len: 0 */
/**
  * @brief This event is generated when a pairing request is issued in response to a slave security
request from a master which has previously bonded with the slave. When this event is
received, the upper layer has to issue the command @ref aci_gap_allow_rebond in order to
allow the slave to continue the pairing process with the master.
  * @retval None
*/

tBleStatus aci_gap_bond_lost_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  aci_gap_bond_lost_event();

  return status;
}
/* aci_gap_proc_complete_event */
/* Event len: 1 + 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is sent by the GAP to the upper layers when a procedure previously started has
been terminated by the upper layer or has completed for any other reason
  * @param Procedure_Code Terminated procedure.
0x01 LIMITED_DISCOVERY_PROC,
0x02 GENERAL_DISCOVERY_PROC,
0x04 NAME_DISCOVERY_PROC,
0x08 AUTO_CONNECTION_ESTABLISHMENT_PROC,
0x10 GENERAL_CONNECTION_ESTABLISHMENT_PROC,
0x20 SELECTIVE_CONNECTION_ESTABLISHMENT_PROC,
0x40 DIRECT_CONNECTION_ESTABLISHMENT_PROC
0x80 OBSERVATION_PROC
  * @param Status Error code
  * @param Data_Length Length of Data in octets
  * @param Data Procedure Specific Data:
- For Name Discovery Procedure: the name of the peer device if the procedure completed successfully.
  * @retval None
*/

tBleStatus aci_gap_proc_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_proc_complete_event_rp0 *rp0 = (aci_gap_proc_complete_event_rp0 *)buffer_in;
  aci_gap_proc_complete_event(rp0->Procedure_Code,
                              rp0->Status,
                              rp0->Data_Length,
                              rp0->Data);

  return status;
}
/* aci_gap_addr_not_resolved_event */
/* Event len: 2 */
/**
  * @brief This event is sent only by a privacy enabled Peripheral. The event is sent to the
upper layers when the peripheral is unsuccessful in resolving the resolvable
address of the peer device after connecting to it.
  * @param Connection_Handle Connection handle for which the private address could not be
resolved with any of the stored IRK's.
  * @retval None
*/

tBleStatus aci_gap_addr_not_resolved_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gap_addr_not_resolved_event_rp0 *rp0 = (aci_gap_addr_not_resolved_event_rp0 *)buffer_in;
  aci_gap_addr_not_resolved_event(rp0->Connection_Handle);

  return status;
}
/* aci_l2cap_connection_update_resp_event */
/* Event len: 2 + 2 */
/**
  * @brief This event is generated when the master responds to the connection update request packet
with a connection update response packet.
  * @param Connection_Handle Connection handle referring to the COS Channel where the Disconnection has been received.
  * @param Result 
  * @retval None
*/

tBleStatus aci_l2cap_connection_update_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_l2cap_connection_update_resp_event_rp0 *rp0 = (aci_l2cap_connection_update_resp_event_rp0 *)buffer_in;
  aci_l2cap_connection_update_resp_event(rp0->Connection_Handle,
                                         rp0->Result);

  return status;
}
/* aci_l2cap_proc_timeout_event */
/* Event len: 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated when the master does not respond to the connection update
request packet with a connection update response packet or a command reject packet
within 30 seconds.
  * @param Connection_Handle Handle of the connection related to this
L2CAP procedure.
  * @param Data_Length Length of following data
  * @param Data Not available
  * @retval None
*/

tBleStatus aci_l2cap_proc_timeout_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_l2cap_proc_timeout_event_rp0 *rp0 = (aci_l2cap_proc_timeout_event_rp0 *)buffer_in;
  aci_l2cap_proc_timeout_event(rp0->Connection_Handle,
                               rp0->Data_Length,
                               rp0->Data);

  return status;
}
/* aci_l2cap_connection_update_req_event */
/* Event len: 2 + 1 + 2 + 2 + 2 + 2 + 2 */
/**
  * @brief The event is given by the L2CAP layer when a connection update request is received from
the slave. The upper layer which receives this event has to respond by sending a
@ref aci_l2cap_connection_parameter_update_resp command.
  * @param Connection_Handle Handle of the connection related to this
L2CAP procedure.
  * @param Identifier This is the identifier which associate the request to the
response.
  * @param L2CAP_Length Length of the L2CAP connection update request.
  * @param Interval_Min N = 0xXXXX    Minimum value for the connection event interval. This shall be less
than or equal to Conn_Interval_Max.
Range: 0x0006 to 0x0C80
Time = N * 1.25 msec
Time Range: 7.5 msec to 4 seconds.
0x0000 - 0x0005 and 0x0C81 - 0xFFFF Reserved for future use
  * @param Interval_Max N = 0xXXXX    Maximum value for the connection event interval. This shall be
greater than or equal to Conn_Interval_Min.
Range: 0x0006 to 0x0C80
Time = N * 1.25 msec
Time Range: 7.5 msec to 4 seconds.
0x0000 - 0x0005 and 0x0C81 - 0xFFFF Reserved for future use
  * @param Slave_Latency Slave latency for the connection in number of connection events.
Range: 0x0000 to 0x01F3
  * @param Timeout_Multiplier Defines connection timeout parameter in the following manner: Timeout Multiplier * 10ms.
  * @retval None
*/

tBleStatus aci_l2cap_connection_update_req_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_l2cap_connection_update_req_event_rp0 *rp0 = (aci_l2cap_connection_update_req_event_rp0 *)buffer_in;
  aci_l2cap_connection_update_req_event(rp0->Connection_Handle,
                                        rp0->Identifier,
                                        rp0->L2CAP_Length,
                                        rp0->Interval_Min,
                                        rp0->Interval_Max,
                                        rp0->Slave_Latency,
                                        rp0->Timeout_Multiplier);

  return status;
}
/* aci_gatt_attribute_modified_event */
/* Event len: 2 + 2 + 2 + 1 + rp0->Attr_Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated to the application by the GATT server when a client modifies any
attribute on the server, as consequence of one of the following GATT procedures:
- write without response
- signed write without response
- write characteristic value
- write long characteristic value
- reliable write.
  * @param Connection_Handle The connection handle which modified the attribute.
  * @param Attr_Handle Handle of the attribute that was modified.
  * @param Offset Offset from which the write has been performed by the peer device.
  * @param Attr_Data_Length Length of Attr_Data in octets
  * @param Attr_Data The modified value
  * @retval None
*/

tBleStatus aci_gatt_attribute_modified_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_attribute_modified_event_rp0 *rp0 = (aci_gatt_attribute_modified_event_rp0 *)buffer_in;
  aci_gatt_attribute_modified_event(rp0->Connection_Handle,
                                    rp0->Attr_Handle,
                                    rp0->Offset,
                                    rp0->Attr_Data_Length,
                                    rp0->Attr_Data);

  return status;
}
/* aci_gatt_proc_timeout_event */
/* Event len: 2 */
/**
  * @brief This event is generated by the client/server to the application on a GATT timeout (30
seconds). This is a critical event that should not happen during normal operating conditions. It is an indication of either a major disruption in the communication link or a mistake in the application which does not provide a reply to GATT procedures. After this event, the GATT channel is closed and no more GATT communication can be performed. The applications is exptected to issue an @ref aci_gap_terminate to disconnect from the peer device. It is important to leave an 100 ms blank window before sending the @ref aci_gap_terminate, since immediately after this event, system could save important information in non volatile memory.
  * @param Connection_Handle Connection handle on which the GATT procedure has timed out
  * @retval None
*/

tBleStatus aci_gatt_proc_timeout_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_proc_timeout_event_rp0 *rp0 = (aci_gatt_proc_timeout_event_rp0 *)buffer_in;
  aci_gatt_proc_timeout_event(rp0->Connection_Handle);

  return status;
}
/* aci_att_exchange_mtu_resp_event */
/* Event len: 2 + 2 */
/**
  * @brief This event is generated in response to an Exchange MTU request. See
@ref aci_gatt_exchange_config.
  * @param Connection_Handle Connection handle related to the response
  * @param Server_RX_MTU Attribute server receive MTU size
  * @retval None
*/

tBleStatus aci_att_exchange_mtu_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_exchange_mtu_resp_event_rp0 *rp0 = (aci_att_exchange_mtu_resp_event_rp0 *)buffer_in;
  aci_att_exchange_mtu_resp_event(rp0->Connection_Handle,
                                  rp0->Server_RX_MTU);

  return status;
}
/* aci_att_find_info_resp_event */
/* Event len: 2 + 1 + 1 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Find Information Request. See
@ref aci_att_find_info_req and Find Information Response in Bluetooth Core v4.1
spec.
  * @param Connection_Handle Connection handle related to the response
  * @param Format Format of the hanndle-uuid pairs
  * @param Event_Data_Length Length of Handle_UUID_Pair in octets
  * @param Handle_UUID_Pair A sequence of handle-uuid pairs. if format=1, each pair is:[2 octets for handle, 2 octets for UUIDs], if format=2, each pair is:[2 octets for handle, 16 octets for UUIDs]
  * @retval None
*/

tBleStatus aci_att_find_info_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_find_info_resp_event_rp0 *rp0 = (aci_att_find_info_resp_event_rp0 *)buffer_in;
  aci_att_find_info_resp_event(rp0->Connection_Handle,
                               rp0->Format,
                               rp0->Event_Data_Length,
                               rp0->Handle_UUID_Pair);

  return status;
}
/* aci_att_find_by_type_value_resp_event */
/* Event len: 2 + 1 + rp0->Num_of_Handle_Pair * (sizeof(Attribute_Group_Handle_Pair_t)) */
/**
  * @brief This event is generated in response to a @ref aci_att_find_by_type_value_req
  * @param Connection_Handle Connection handle related to the response
  * @param Num_of_Handle_Pair Number of attribute, group handle pairs
  * @param Attribute_Group_Handle_Pair See @ref Attribute_Group_Handle_Pair_t
  * @retval None
*/

tBleStatus aci_att_find_by_type_value_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_find_by_type_value_resp_event_rp0 *rp0 = (aci_att_find_by_type_value_resp_event_rp0 *)buffer_in;
  uint8_t size = 3;
  int i;
  Attribute_Group_Handle_Pair_t Attribute_Group_Handle_Pair[HCI_MAX_PAYLOAD_SIZE/sizeof(Attribute_Group_Handle_Pair_t)];
  for (i = 0; i < rp0->Num_of_Handle_Pair; i++) {
    Attribute_Group_Handle_Pair[i].Found_Attribute_Handle = rp0->Attribute_Group_Handle_Pair[i].Found_Attribute_Handle;
    size += 2;
    Attribute_Group_Handle_Pair[i].Group_End_Handle = rp0->Attribute_Group_Handle_Pair[i].Group_End_Handle;
    size += 2;
  }
  aci_att_find_by_type_value_resp_event(rp0->Connection_Handle,
                                        rp0->Num_of_Handle_Pair,
                                        Attribute_Group_Handle_Pair);

  return status;
}
/* aci_att_read_by_type_resp_event */
/* Event len: 2 + 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a @ref aci_att_read_by_type_req. See
@ref aci_gatt_find_included_services and @ref aci_gatt_disc_all_char_desc.
  * @param Connection_Handle Connection handle related to the response
  * @param Handle_Value_Pair_Length The size of each attribute handle-value pair
  * @param Data_Length Length of Handle_Value_Pair_Data in octets
  * @param Handle_Value_Pair_Data Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of handle-value pairs: [2 octets for Attribute Handle, (Handle_Value_Pair_Length - 2 octets) for Attribute Value]
  * @retval None
*/

tBleStatus aci_att_read_by_type_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_by_type_resp_event_rp0 *rp0 = (aci_att_read_by_type_resp_event_rp0 *)buffer_in;
  aci_att_read_by_type_resp_event(rp0->Connection_Handle,
                                  rp0->Handle_Value_Pair_Length,
                                  rp0->Data_Length,
                                  rp0->Handle_Value_Pair_Data);

  return status;
}
/* aci_att_read_resp_event */
/* Event len: 2 + 1 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Read Request. See @ref aci_gatt_read_char_value.
  * @param Connection_Handle Connection handle related to the response
  * @param Event_Data_Length Length of following data
  * @param Attribute_Value The value of the attribute.
  * @retval None
*/

tBleStatus aci_att_read_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_resp_event_rp0 *rp0 = (aci_att_read_resp_event_rp0 *)buffer_in;
  aci_att_read_resp_event(rp0->Connection_Handle,
                          rp0->Event_Data_Length,
                          rp0->Attribute_Value);

  return status;
}
/* aci_att_read_blob_resp_event */
/* Event len: 2 + 1 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Read Request. See @ref aci_gatt_read_char_value.
  * @param Connection_Handle Connection handle related to the response
  * @param Event_Data_Length Length of following data
  * @param Attribute_Value Part of the attribute value.
  * @retval None
*/

tBleStatus aci_att_read_blob_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_blob_resp_event_rp0 *rp0 = (aci_att_read_blob_resp_event_rp0 *)buffer_in;
  aci_att_read_blob_resp_event(rp0->Connection_Handle,
                               rp0->Event_Data_Length,
                               rp0->Attribute_Value);

  return status;
}
/* aci_att_read_multiple_resp_event */
/* Event len: 2 + 1 + rp0->Event_Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Read Multiple Request.
  * @param Connection_Handle Connection handle related to the response
  * @param Event_Data_Length Length of following data
  * @param Set_Of_Values A set of two or more values.
A concatenation of attribute values for each of the attribute handles in the request in the order that they were requested.
  * @retval None
*/

tBleStatus aci_att_read_multiple_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_multiple_resp_event_rp0 *rp0 = (aci_att_read_multiple_resp_event_rp0 *)buffer_in;
  aci_att_read_multiple_resp_event(rp0->Connection_Handle,
                                   rp0->Event_Data_Length,
                                   rp0->Set_Of_Values);

  return status;
}
/* aci_att_read_by_group_type_resp_event */
/* Event len: 2 + 1 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a Read By Group Type Request. See
@ref aci_gatt_disc_all_primary_services.
  * @param Connection_Handle Connection handle related to the response
  * @param Attribute_Data_Length The size of each attribute data
  * @param Data_Length Length of Attribute_Data_List in octets
  * @param Attribute_Data_List Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of attribute handle, end group handle, attribute value tuples: [2 octets for Attribute Handle, 2 octets End Group Handle, (Attribute_Data_Length - 4 octets) for Attribute Value]
  * @retval None
*/

tBleStatus aci_att_read_by_group_type_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_read_by_group_type_resp_event_rp0 *rp0 = (aci_att_read_by_group_type_resp_event_rp0 *)buffer_in;
  aci_att_read_by_group_type_resp_event(rp0->Connection_Handle,
                                        rp0->Attribute_Data_Length,
                                        rp0->Data_Length,
                                        rp0->Attribute_Data_List);

  return status;
}
/* aci_att_prepare_write_resp_event */
/* Event len: 2 + 2 + 2 + 1 + rp0->Part_Attribute_Value_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated in response to a @ref aci_att_prepare_write_req.
  * @param Connection_Handle Connection handle related to the response
  * @param Attribute_Handle The handle of the attribute to be written
  * @param Offset The offset of the first octet to be written.
  * @param Part_Attribute_Value_Length Length of Part_Attribute_Value in octets
  * @param Part_Attribute_Value The value of the attribute to be written
  * @retval None
*/

tBleStatus aci_att_prepare_write_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_prepare_write_resp_event_rp0 *rp0 = (aci_att_prepare_write_resp_event_rp0 *)buffer_in;
  aci_att_prepare_write_resp_event(rp0->Connection_Handle,
                                   rp0->Attribute_Handle,
                                   rp0->Offset,
                                   rp0->Part_Attribute_Value_Length,
                                   rp0->Part_Attribute_Value);

  return status;
}
/* aci_att_exec_write_resp_event */
/* Event len: 2 */
/**
  * @brief This event is generated in response to an Execute Write Request.
  * @param Connection_Handle Connection handle related to the response
  * @retval None
*/

tBleStatus aci_att_exec_write_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_att_exec_write_resp_event_rp0 *rp0 = (aci_att_exec_write_resp_event_rp0 *)buffer_in;
  aci_att_exec_write_resp_event(rp0->Connection_Handle);

  return status;
}
/* aci_gatt_indication_event */
/* Event len: 2 + 2 + 1 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated when an indication is received from the server.
  * @param Connection_Handle Connection handle related to the response
  * @param Attribute_Handle The handle of the attribute
  * @param Attribute_Value_Length Length of Attribute_Value in octets
  * @param Attribute_Value The current value of the attribute
  * @retval None
*/

tBleStatus aci_gatt_indication_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_indication_event_rp0 *rp0 = (aci_gatt_indication_event_rp0 *)buffer_in;
  aci_gatt_indication_event(rp0->Connection_Handle,
                            rp0->Attribute_Handle,
                            rp0->Attribute_Value_Length,
                            rp0->Attribute_Value);

  return status;
}
/* aci_gatt_notification_event */
/* Event len: 2 + 2 + 1 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated when a notification is received from the server.
  * @param Connection_Handle Connection handle related to the response
  * @param Attribute_Handle The handle of the attribute
  * @param Attribute_Value_Length Length of Attribute_Value in octets
  * @param Attribute_Value The current value of the attribute
  * @retval None
*/

tBleStatus aci_gatt_notification_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_notification_event_rp0 *rp0 = (aci_gatt_notification_event_rp0 *)buffer_in;
  aci_gatt_notification_event(rp0->Connection_Handle,
                              rp0->Attribute_Handle,
                              rp0->Attribute_Value_Length,
                              rp0->Attribute_Value);

  return status;
}
/* aci_gatt_proc_complete_event */
/* Event len: 2 + 1 */
/**
  * @brief This event is generated when a GATT client procedure completes either with error or
successfully.
  * @param Connection_Handle Connection handle related to the response
  * @param Error_Code Indicates whether the procedure completed with an error or was successful
  * @retval None
*/

tBleStatus aci_gatt_proc_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_proc_complete_event_rp0 *rp0 = (aci_gatt_proc_complete_event_rp0 *)buffer_in;
  aci_gatt_proc_complete_event(rp0->Connection_Handle,
                               rp0->Error_Code);

  return status;
}
/* aci_gatt_error_resp_event */
/* Event len: 2 + 1 + 2 + 1 */
/**
  * @brief This event is generated when an Error Response is received from the server. The error
response can be given by the server at the end of one of the GATT discovery procedures.
This does not mean that the procedure ended with an error, but this error event is part of the
procedure itself.
  * @param Connection_Handle Connection handle related to the response
  * @param Req_Opcode The request that generated this error response
  * @param Attribute_Handle The attribute handle that generated this error response
  * @param Error_Code The reason why the request has generated an error response (ATT error codes)
  * @retval None
*/

tBleStatus aci_gatt_error_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_error_resp_event_rp0 *rp0 = (aci_gatt_error_resp_event_rp0 *)buffer_in;
  aci_gatt_error_resp_event(rp0->Connection_Handle,
                            rp0->Req_Opcode,
                            rp0->Attribute_Handle,
                            rp0->Error_Code);

  return status;
}
/* aci_gatt_disc_read_char_by_uuid_resp_event */
/* Event len: 2 + 2 + 1 + rp0->Attribute_Value_Length * (sizeof(uint8_t)) */
/**
  * @brief This event can be generated during a "Discover Characteristics By UUID" procedure or a
"Read using Characteristic UUID" procedure.
The attribute value will be a service declaration as defined in Bluetooth Core v4.1spec
(vol.3, Part G, ch. 3.3.1), when a "Discover Characteristics By UUID" has been started. It will
be the value of the Characteristic if a* "Read using Characteristic UUID" has been
performed.
  * @param Connection_Handle Connection handle related to the response
  * @param Attribute_Handle The handle of the attribute
  * @param Attribute_Value_Length Length of Attribute_Value in octets
  * @param Attribute_Value The attribute value will be a service declaration as defined in Bluetooth Core v4.0 spec
 (vol.3, Part G, ch. 3.3.1), when a "Discover Characteristics By UUID" has been started.
 It will be the value of the Characteristic if a "Read using Characteristic UUID" has been performed.
  * @retval None
*/

tBleStatus aci_gatt_disc_read_char_by_uuid_resp_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_disc_read_char_by_uuid_resp_event_rp0 *rp0 = (aci_gatt_disc_read_char_by_uuid_resp_event_rp0 *)buffer_in;
  aci_gatt_disc_read_char_by_uuid_resp_event(rp0->Connection_Handle,
                                             rp0->Attribute_Handle,
                                             rp0->Attribute_Value_Length,
                                             rp0->Attribute_Value);

  return status;
}
/* aci_gatt_write_permit_req_event */
/* Event len: 2 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is given to the application when a write request, write command or signed write
command is received by the server from the client. This event will be given to the application
only if the event bit for this event generation is set when the characteristic was added.
When this event is received, the application has to check whether the value being requested
for write can be allowed to be written and respond with the command @ref aci_gatt_write_resp.
The details of the parameters of the command can be found. Based on the response from
the application, the attribute value will be modified by the stack. If the write is rejected by the
application, then the value of the attribute will not be modified. In case of a write REQ, an
error response will be sent to the client, with the error code as specified by the application.
In case of write/signed write commands, no response is sent to the client but the attribute is
not modified.
  * @param Connection_Handle Handle of the connection on which there was the request to write the attribute
  * @param Attribute_Handle The handle of the attribute
  * @param Data_Length Length of Data field
  * @param Data The data that the client has requested to write
  * @retval None
*/

tBleStatus aci_gatt_write_permit_req_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_write_permit_req_event_rp0 *rp0 = (aci_gatt_write_permit_req_event_rp0 *)buffer_in;
  aci_gatt_write_permit_req_event(rp0->Connection_Handle,
                                  rp0->Attribute_Handle,
                                  rp0->Data_Length,
                                  rp0->Data);

  return status;
}
/* aci_gatt_read_permit_req_event */
/* Event len: 2 + 2 + 2 */
/**
  * @brief This event is given to the application when a read request or read blob request is received
by the server from the client. This event will be given to the application only if the event bit
for this event generation is set when the characteristic was added.
On receiving this event, the application can update the value of the handle if it desires and
when done, it has to send the @ref aci_gatt_allow_read command to indicate to the stack that it
can send the response to the client.
  * @param Connection_Handle Connection handle related to the response
  * @param Attribute_Handle The handle of the attribute
  * @param Offset Contains the offset from which the read has been requested
  * @retval None
*/

tBleStatus aci_gatt_read_permit_req_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_read_permit_req_event_rp0 *rp0 = (aci_gatt_read_permit_req_event_rp0 *)buffer_in;
  aci_gatt_read_permit_req_event(rp0->Connection_Handle,
                                 rp0->Attribute_Handle,
                                 rp0->Offset);

  return status;
}
/* aci_gatt_read_multi_permit_req_event */
/* Event len: 2 + 1 + rp0->Number_of_Handles * (sizeof(Handle_Item_t)) */
/**
  * @brief This event is given to the application when a read multiple request or read by type request is
received by the server from the client. This event will be given to the application only if the
event bit for this event generation is set when the characteristic was added.
On receiving this event, the application can update the values of the handles if it desires and
when done, it has to send the @ref aci_gatt_allow_read command to indicate to the stack that it
can send the response to the client.
  * @param Connection_Handle Handle of the connection which requested to read the attribute
  * @param Number_of_Handles Not available
  * @param Handle_Item See @ref Handle_Item_t
  * @retval None
*/

tBleStatus aci_gatt_read_multi_permit_req_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_read_multi_permit_req_event_rp0 *rp0 = (aci_gatt_read_multi_permit_req_event_rp0 *)buffer_in;
  uint8_t size = 3;
  int i;
  Handle_Item_t Handle_Item[HCI_MAX_PAYLOAD_SIZE/sizeof(Handle_Item_t)];
  for (i = 0; i < rp0->Number_of_Handles; i++) {
    Handle_Item[i].Handle = rp0->Handle_Item[i].Handle;
    size += 2;
  }
  aci_gatt_read_multi_permit_req_event(rp0->Connection_Handle,
                                       rp0->Number_of_Handles,
                                       Handle_Item);

  return status;
}
/* hci_le_connection_complete_event */
/* Event len: 1 + 2 + 1 + 1 + 6 + 2 + 2 + 2 + 1 */
/**
  * @brief The LE Connection Complete event indicates to both of the Hosts forming the
connection that a new connection has been created. Upon the creation of the
connection a Connection_Handle shall be assigned by the Controller, and
passed to the Host in this event. If the connection establishment fails this event
shall be provided to the Host that had issued the LE_Create_Connection command.
This event indicates to the Host which issued a LE_Create_Connection
command and received a Command Status event if the connection
establishment failed or was successful.
The Master_Clock_Accuracy parameter is only valid for a slave. On a master,
this parameter shall be set to 0x00.
  * @param Status Error code
  * @param Connection_Handle Connection_Handle to be used to identify a connection between two
Bluetooth devices. 
Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
  * @param Role 0x00 Connection is master
0x01 Connection is slave
0x02-0xFF Reserved for future use
  * @param Peer_Address_Type The address type of the peer device:
0x00 Public Device Address
0x01 Random Device Address
0x02-0xFF Reserved for future use
  * @param Peer_Address Public Device Address or Random Device Address of the peer
device
  * @param Conn_Interval Connection interval used on this connection.
Range: 0x0006 to 0x0C80
Time = N * 1.25 msec
Time Range: 7.5 msec to 4000 msec.
  * @param Conn_Latency Slave latency for the connection in number of connection events.
Range: 0x0000 to 0x01F3
  * @param Supervision_Timeout N = 0xXXXX    Supervision timeout for the LE Link. (See [Vol 6] Part B, Section
4.5.2)
Range: 0x000A to 0x0C80
Time = N * 10 msec
Time Range: 100 msec to 32 seconds
0x0000 - 0x0009 and
0x0C81 - 0xFFFF Reserved for future use
  * @param Master_Clock_Accuracy 0x00 500 ppm
0x01 250 ppm
0x02 150 ppm
0x03 100 ppm
0x04 75 ppm
0x05 50 ppm
0x06 30 ppm
0x07 20 ppm
0x08-0xFF Reserved for future use
  * @retval None
*/

tBleStatus hci_le_connection_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_connection_complete_event_rp0 *rp0 = (hci_le_connection_complete_event_rp0 *)buffer_in;
  hci_le_connection_complete_event(rp0->Status,
                                   rp0->Connection_Handle,
                                   rp0->Role,
                                   rp0->Peer_Address_Type,
                                   rp0->Peer_Address,
                                   rp0->Conn_Interval,
                                   rp0->Conn_Latency,
                                   rp0->Supervision_Timeout,
                                   rp0->Master_Clock_Accuracy);

  return status;
}
/* hci_le_advertising_report_event */
/* Event len: 1 + rp0->Num_Reports * (sizeof(Advertising_Report_t)) */
/**
  * @brief The LE Advertising Report event indicates that a Bluetooth device or multiple
Bluetooth devices have responded to an active scan or received some information
during a passive scan. The Controller may queue these advertising reports
and send information from multiple devices in one LE Advertising Report event.
  * @param Num_Reports 0x01 - 0x19 Number of responses in event.
  * @param Advertising_Report See @ref Advertising_Report_t
  * @retval None
*/

tBleStatus hci_le_advertising_report_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_advertising_report_event_rp0 *rp0 = (hci_le_advertising_report_event_rp0 *)buffer_in;
  uint8_t size = 1;
  int i;
  Advertising_Report_t Advertising_Report[HCI_MAX_PAYLOAD_SIZE/sizeof(Advertising_Report_t)];
  for (i = 0; i < rp0->Num_Reports; i++) {
    Advertising_Report[i].Event_Type = rp0->Advertising_Report[i].Event_Type;
    size += 1;
    Advertising_Report[i].Address_Type = rp0->Advertising_Report[i].Address_Type;
    size += 1;
    Osal_MemCpy((void *) Advertising_Report[i].Address, (const void *) rp0->Advertising_Report[i].Address, 6);
    size += 6;
    Advertising_Report[i].Length_Data = rp0->Advertising_Report[i].Length_Data;
    size += 1;
    Advertising_Report[i].Data = rp0->Advertising_Report[i].Data;
    size += rp0->Advertising_Report[i].Length_Data;

    Advertising_Report[i].RSSI = (uint8_t)buffer_in[size];
    size += 1;
  }
  hci_le_advertising_report_event(rp0->Num_Reports,
                                  Advertising_Report);

  return status;
}
/* hci_le_connection_update_complete_event */
/* Event len: 1 + 2 + 2 + 2 + 2 */
/**
  * @brief The LE Connection Update Complete event is used to indicate that the Controller
process to update the connection has completed.
On a slave, if no connection parameters are updated, then this event shall not be issued.
On a master, this event shall be issued if the Connection_Update command was sent.
  * @param Status Error code
  * @param Connection_Handle Connection_Handle to be used to identify a connection between two
Bluetooth devices.
Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
  * @param Conn_Interval Connection interval used on this connection.
Range: 0x0006 to 0x0C80
Time = N * 1.25 msec
Time Range: 7.5 msec to 4000 msec.
  * @param Conn_Latency Slave latency for the connection in number of connection events.
Range: 0x0000 to 0x01F3
  * @param Supervision_Timeout N = 0xXXXX    Supervision timeout for the LE Link. (See [Vol 6] Part B, Section
4.5.2)
Range: 0x000A to 0x0C80
Time = N * 10 msec
Time Range: 100 msec to 32 seconds
0x0000 - 0x0009 and
0x0C81 - 0xFFFF Reserved for future use
  * @retval None
*/

tBleStatus hci_le_connection_update_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_connection_update_complete_event_rp0 *rp0 = (hci_le_connection_update_complete_event_rp0 *)buffer_in;
  hci_le_connection_update_complete_event(rp0->Status,
                                          rp0->Connection_Handle,
                                          rp0->Conn_Interval,
                                          rp0->Conn_Latency,
                                          rp0->Supervision_Timeout);

  return status;
}
/* hci_le_read_remote_used_features_complete_event */
/* Event len: 1 + 2 + 8 */
/**
  * @brief The LE Read Remote Used Features Complete event is used to indicate the
completion of the process of the Controller obtaining the used features of the
remote Bluetooth device specified by the Connection_Handle event parameter.
  * @param Status Error code
  * @param Connection_Handle Connection_Handle to be used to identify a connection between two
Bluetooth devices. 
Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
  * @param LE_Features Bit Mask List of used LE features. For details see LE Link Layer specification.
  * @retval None
*/

tBleStatus hci_le_read_remote_used_features_complete_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_read_remote_used_features_complete_event_rp0 *rp0 = (hci_le_read_remote_used_features_complete_event_rp0 *)buffer_in;
  hci_le_read_remote_used_features_complete_event(rp0->Status,
                                                  rp0->Connection_Handle,
                                                  rp0->LE_Features);

  return status;
}
/* hci_le_long_term_key_request_event */
/* Event len: 2 + 8 + 2 */
/**
  * @brief The LE Long Term Key Request event indicates that the master device is
attempting to encrypt or re-encrypt the link and is requesting the Long Term
Key from the Host. (See [Vol 6] Part B, Section 5.1.3).
  * @param Connection_Handle Connection_Handle to be used to identify a connection between two
Bluetooth devices. 
Range: 0x0000-0x0EFF (0x0F00 - 0x0FFF Reserved for future use)
  * @param Random_Number 64-bit random number
  * @param Encrypted_Diversifier 16-bit encrypted diversifier
  * @retval None
*/

tBleStatus hci_le_long_term_key_request_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  hci_le_long_term_key_request_event_rp0 *rp0 = (hci_le_long_term_key_request_event_rp0 *)buffer_in;
  hci_le_long_term_key_request_event(rp0->Connection_Handle,
                                     rp0->Random_Number,
                                     rp0->Encrypted_Diversifier);

  return status;
}
/* aci_l2cap_command_reject_event */
/* Event len: 2 + 1 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is generated when the master responds to the connection update request packet
with a command reject packet.
  * @param Connection_Handle Connection handle referring to the COS Channel where the Disconnection has been received.
  * @param Identifier This is the identifier which associate the request to the
response.
  * @param Reason Reason
  * @param Data_Length Length of following data
  * @param Data Data field associated with Reason
  * @retval None
*/

tBleStatus aci_l2cap_command_reject_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_l2cap_command_reject_event_rp0 *rp0 = (aci_l2cap_command_reject_event_rp0 *)buffer_in;
  aci_l2cap_command_reject_event(rp0->Connection_Handle,
                                 rp0->Identifier,
                                 rp0->Reason,
                                 rp0->Data_Length,
                                 rp0->Data);

  return status;
}
/* aci_hal_end_of_radio_activity_event */
/* Event len: 1 + 1 + 4 */
/**
  * @brief This event is generated when the device completes a radio activity and provide information when a new radio acitivity will be performed.
Informtation provided includes type of radio activity and absolute time in system ticks when a new radio acitivity is schedule, if any. Application can use this information to schedule user activities synchronous to selected radio activitities. A command @ref aci_hal_set_radio_activity_mask is provided to enable radio activity events of user interests, by default no events are enabled.
User should take into account that enablinng radio events in application with intense radio activity could lead to a fairly high rate of events generated.
Application use cases includes synchronizing notification with connection interval, switiching antenna at the end of advertising or performing flash erase operation while radio is idle.
  * @param Last_State Completed radio events
  * @param Next_State Incoming radio events
  * @param Next_State_SysTime 32bit absolute current time expressed in internal time units.
  * @retval None
*/

tBleStatus aci_hal_end_of_radio_activity_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_hal_end_of_radio_activity_event_rp0 *rp0 = (aci_hal_end_of_radio_activity_event_rp0 *)buffer_in;
  aci_hal_end_of_radio_activity_event(rp0->Last_State,
                                      rp0->Next_State,
                                      rp0->Next_State_SysTime);

  return status;
}
/* aci_gatt_tx_pool_available_event */
/* Event len: 2 + 2 */
/**
  * @brief Each time BLE FW stack raises the error code
BLE_STATUS_INSUFFICIENT_RESOURCES (0x64), the
@ref aci_gatt_tx_pool_available_event event is generated as soon as there are at least two
buffers available for notifications or write commands.
  * @param Connection_Handle Connection handle related to the request
  * @param Available_Buffers Number of buffers available
  * @retval None
*/

tBleStatus aci_gatt_tx_pool_available_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_tx_pool_available_event_rp0 *rp0 = (aci_gatt_tx_pool_available_event_rp0 *)buffer_in;
  aci_gatt_tx_pool_available_event(rp0->Connection_Handle,
                                   rp0->Available_Buffers);

  return status;
}
/* aci_gatt_server_confirmation_event */
/* Event len: 2 */
/**
  * @brief This event is generated when the client has sent the confirmation to a previously sent indication
  * @param Connection_Handle Connection handle related to the event
  * @retval None
*/

tBleStatus aci_gatt_server_confirmation_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_server_confirmation_event_rp0 *rp0 = (aci_gatt_server_confirmation_event_rp0 *)buffer_in;
  aci_gatt_server_confirmation_event(rp0->Connection_Handle);

  return status;
}
/* aci_blue_events_lost_event */
/* Event len: 8 */
/**
  * @brief This event is generated when an overflow occurs in the event queue read by the
external microcontroller. This is normally caused when the external microcontroller does 
not read pending events. The returned bitmap indicates which event has been lost. Please
 note that one bit set to 1 indicates one or more occurrences of the particular events.
The event ACI_BLUE_EVENTS_LOST_EVENT cannot be lost and it will inserted in the
event queue as soon as a position is freed in the event queue. This event should not happen under normal
operating condition where external microcontroller promptly reads events signaled by IRQ pin.
It is provided to detected unexpected behavior of the external microcontroller or to
allow application to recover situations where critical events are lost.
  * @param Lost_Events Bitmap of lost events. Each bit indicates one or more occurrences of the specific event:
0x0000000000000001 HCI_DISCONNECTION_COMPLETE_EVENT
0x0000000000000002 HCI_ENCRYPTION_CHANGE_EVENT
0x0000000000000004 HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVENT
0x0000000000000008 HCI_COMMAND_COMPLETE_EVENT
0x0000000000000010 HCI_COMMAND_STATUS_EVENT
0x0000000000000020 HCI_HARDWARE_ERROR_EVENT
0x0000000000000040 HCI_NUMBER_OF_COMPLETED_PACKETS_EVENT
0x0000000000000080 HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVENT
0x0000000000000100 ACI_BLUE_INITIALIZED_EVENT
0x0000000000000200 ACI_GAP_LIMITED_DISCOVERABLE_EVENT
0x0000000000000400 ACI_GAP_PAIRING_COMPLETE_EVENT
0x0000000000000800 ACI_GAP_PASS_KEY_REQ_EVENT
0x0000000000001000 ACI_GAP_AUTHORIZATION_REQ_EVENT
0x0000000000002000 ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT
0x0000000000004000 ACI_GAP_BOND_LOST_EVENT
0x0000000000008000 ACI_GAP_PROC_COMPLETE_EVENT
0x0000000000010000 ACI_GAP_ADDR_NOT_RESOLVED_EVENT
0x0000000000020000 ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT
0x0000000000040000 ACI_L2CAP_PROC_TIMEOUT_EVENT
0x0000000000080000 ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT
0x0000000000100000 ACI_GATT_ATTRIBUTE_MODIFIED_EVENT
0x0000000000200000 ACI_GATT_PROC_TIMEOUT_EVENT
0x0000000000400000 ACI_ATT_EXCHANGE_MTU_RESP_EVENT
0x0000000000800000 ACI_ATT_FIND_INFO_RESP_EVENT
0x0000000001000000 ACI_ATT_FIND_BY_TYPE_VALUE_RESP_EVENT
0x0000000002000000 ACI_ATT_READ_BY_TYPE_RESP_EVENT
0x0000000004000000 ACI_ATT_READ_RESP_EVENT
0x0000000008000000 ACI_ATT_READ_BLOB_RESP_EVENT
0x0000000010000000 ACI_ATT_READ_MULTIPLE_RESP_EVENT
0x0000000020000000 ACI_ATT_READ_BY_GROUP_TYPE_RESP_EVENT
0x0000000040000000 ACI_ATT_WRITE_RESP_EVENT
0x0000000080000000 ACI_ATT_PREPARE_WRITE_RESP_EVENT
0x0000000100000000 ACI_ATT_EXEC_WRITE_RESP_EVENT
0x0000000200000000 ACI_GATT_INDICATION_EVENT
0x0000000400000000 ACI_GATT_NOTIFICATION_EVENT
0x0000000800000000 ACI_GATT_PROC_COMPLETE_EVENT
0x0000001000000000 ACI_GATT_ERROR_RESP_EVENT
0x0000002000000000 ACI_GATT_DISC_READ_CHAR_BY_UUID_RESP_EVENT
0x0000004000000000 ACI_GATT_WRITE_PERMIT_REQ_EVENT
0x0000008000000000 ACI_GATT_READ_PERMIT_REQ_EVENT
0x0000010000000000 ACI_GATT_READ_MULTI_PERMIT_REQ_EVENT
0x0000020000000000 ACI_GATT_TX_POOL_AVAILABLE_EVENT
0x0000040000000000 ACI_GATT_SERVER_CONFIRMATION_EVENT
0x0000080000000000 ACI_GATT_PREPARE_WRITE_PERMIT_REQ_EVENT
0x0000100000000000 HCI_LE_CONNECTION_COMPLETE_EVENT
0x0000200000000000 HCI_LE_ADVERTISING_REPORT_EVENT
0x0000400000000000 HCI_LE_CONNECTION_UPDATE_COMPLETE_EVENT
0x0000800000000000 HCI_LE_READ_REMOTE_USED_FEATURES_COMPLETE_EVENT
0x0001000000000000 HCI_LE_LONG_TERM_KEY_REQUEST_EVENT
  * @retval None
*/

tBleStatus aci_blue_events_lost_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_blue_events_lost_event_rp0 *rp0 = (aci_blue_events_lost_event_rp0 *)buffer_in;
  aci_blue_events_lost_event(rp0->Lost_Events);

  return status;
}
/* aci_blue_crash_info_event */
/* Event len: 1 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + rp0->Debug_Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is given to the application after the @ref aci_blue_initialized_event
when a system crash is detected. This events returns system crash information for debugging purposes. 
Information reported are useful to understand the root cause of the crash.
  * @param Crash_Type Crash type
  * @param SP Stack pointer
  * @param R0 Register R0
  * @param R1 Register R1
  * @param R2 Register R2
  * @param R3 Register R3
  * @param R12 Register R12
  * @param LR Link register
  * @param PC Program counter where crash occurred
  * @param xPSR xPSR register
  * @param Debug_Data_Length Length of Debug_Data field
  * @param Debug_Data Debug data
  * @retval None
*/

tBleStatus aci_blue_crash_info_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_blue_crash_info_event_rp0 *rp0 = (aci_blue_crash_info_event_rp0 *)buffer_in;
  aci_blue_crash_info_event(rp0->Crash_Type,
                            rp0->SP,
                            rp0->R0,
                            rp0->R1,
                            rp0->R2,
                            rp0->R3,
                            rp0->R12,
                            rp0->LR,
                            rp0->PC,
                            rp0->xPSR,
                            rp0->Debug_Data_Length,
                            rp0->Debug_Data);

  return status;
}
/* aci_gatt_prepare_write_permit_req_event */
/* Event len: 2 + 2 + 2 + 1 + rp0->Data_Length * (sizeof(uint8_t)) */
/**
  * @brief This event is given to the application when a prepare write request
is received by the server from the client. This event will be given to the application
only if the event bit for this event generation is set when the characteristic was added.
When this event is received, the application has to check whether the value being requested
for write can be allowed to be written and respond with the command @ref aci_gatt_write_resp.
Based on the response from the application, the attribute value will be modified by the stack.
If the write is rejected by the application, then the value of the attribute will not be modified
and an error response will be sent to the client, with the error code as specified by the application.
  * @param Connection_Handle Handle of the connection on which there was the request to write the attribute
  * @param Attribute_Handle The handle of the attribute
  * @param Offset The offset from which the prepare write has been requested
  * @param Data_Length Length of Data field
  * @param Data The data that the client has requested to write
  * @retval None
*/

tBleStatus aci_gatt_prepare_write_permit_req_event_process(uint8_t *buffer_in)
{
  tBleStatus status = BLE_STATUS_SUCCESS;
  /* Input params */
  aci_gatt_prepare_write_permit_req_event_rp0 *rp0 = (aci_gatt_prepare_write_permit_req_event_rp0 *)buffer_in;
  aci_gatt_prepare_write_permit_req_event(rp0->Connection_Handle,
                                          rp0->Attribute_Handle,
                                          rp0->Offset,
                                          rp0->Data_Length,
                                          rp0->Data);

  return status;
}
